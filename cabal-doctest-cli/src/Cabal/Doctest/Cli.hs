{-# LANGUAGE CPP #-}
{-# LANGUAGE OverloadedStrings #-}
-- |
--
-- == Features
--
-- * Doctest comonent have to be named @doctests@
--
-- * @cabal new-build@ as with 2.2 / HEAD are supported.
--
-- * @stack@ support is TODO
--
-- * @default-extensions@ are supported, they are passed to doctest
--
-- * Autogenerated files (e.g. @cabal_macros.h@ for CPP) are supported.
--
-- == Configuration options
--
-- * @x-doctest-options" for additonal options passed to doctest. For example.
--
--   @
--   if impl(ghc >= 8.2)
--     x-doctest-options: -fdiagnostics-color=never
--   @
--
-- * @x-doctest-source-dirs@ Additional directories to look for modules.
--
-- * @x-doctest-modules@ Additional modules (in addition to library component's
--   @exposed-modules@ and @other-modules@).
--
--
--
module Cabal.Doctest.Cli (main) where

import System.IO (hPutStrLn, stderr)
import System.Exit (exitFailure)
import System.FilePath ((</>))
import Data.Foldable (traverse_)
import System.Environment (getEnvironment)

import qualified System.FilePath.Glob as Glob
import qualified Test.DocTest as Doctest
import qualified Cabal.Plan as  P
import qualified Data.Text as T
import qualified Data.Map as Map
import qualified Data.Set as Set

import qualified Distribution.PackageDescription as C
import qualified Distribution.PackageDescription.Parsec as C
import qualified Distribution.Types.CondTree as C
import qualified Distribution.Types.Dependency as C
import qualified Distribution.Types.PackageName as C
import qualified Distribution.Types.PackageId as C
import qualified Distribution.Version as C
import qualified Distribution.Pretty as C
import qualified Distribution.Verbosity as C

import Debug.Trace

#if MIN_VERSION_directory(1,2,2)
import System.Directory
       (makeAbsolute)
#else
import System.Directory
       (getCurrentDirectory)
import System.FilePath
       (isAbsolute)

makeAbsolute :: FilePath -> IO FilePath
makeAbsolute p | isAbsolute p = return p
               | otherwise    = do
    cwd <- getCurrentDirectory
    return $ cwd </> p
#endif

-------------------------------------------------------------------------------
-- Main
-------------------------------------------------------------------------------

-- | Find out the environment, and run doctests there.
main :: IO ()
main = do
    paths <- Glob.glob "*.cabal"
    cabalPath <- case paths of
        []  -> die "No *.cabal file found"
        [x] -> return x
        xs  -> die $ "Multiple *.cabal files found: " ++ show xs

    gpd <- C.readGenericPackageDescription C.silent cabalPath
    let pd = C.packageDescription gpd
    lib <- maybe (die "No library component") return $ C.condLibrary gpd
    doc <- maybe (die "No doctest component") return $ lookup "doctests" $ C.condTestSuites gpd

    env <- getEnvironment
    traverse_ print env
    -- TODO: look for _
    -- look for STACK_EXE

    -- TODO: now we assume we run with @cabal new-build@
    (plan, rootDir) <- P.findAndDecodePlanJson Nothing -- TODO: use envvar to control ?
    cabal pd lib doc plan rootDir


-------------------------------------------------------------------------------
-- Cabal
-------------------------------------------------------------------------------

cabal'
    :: P.Unit       -- ^ library Unit
    -> P.Unit       -- ^ test-suite unit
    -> C.Library    -- ^ library
    -> C.TestSuite  -- ^ test-suite
    -> IO ()
cabal' libUnit docUnit lib doc = do
    print distPref
    print unitIds

    newStyleDb <- makeAbsolute "../dist-newstyle/packagedb/ghc-7.10.3"

--    let dbStack = withPackageDB lbi ++ [ SpecificPackageDB $ distPref </> "package.conf.inplace" ]
    let dbFlags =
            [ "-hide-all-packages"
            , "-global-package-db"
            , "-package-db=" ++ "/home/ogre/.cabal/store/ghc-7.10.3/package.db"
            , "-package-db=" ++ newStyleDb
            , "-package-db=" ++ (compDistDir </> "package.conf.inplace")
            , "-package-db=" ++ (testDistDir </> "package.conf.inplace")
            ]

     -- modules
    let modules = C.exposedModules lib ++ C.otherModules compBI
    -- it seems that doctest is happy to take in module names, not actual files!
    let module_sources = modules

    iArgsNoPrefix <- mapM makeAbsolute
        $ compAutogenDir           -- autogenerated files
        : distPref                 -- preprocessed files (.hsc -> .hs); "build" is hardcoded in Cabal.
        : C.hsSourceDirs compBI
        ++ additionalDirs

    includeArgs <- mapM (fmap ("-I"++) . makeAbsolute) $ C.includeDirs compBI
    -- We clear all includes, so the CWD isn't used.
    let iArgs' = map ("-i"++) iArgsNoPrefix
        iArgs  = "-i" : iArgs'

    -- default-extensions
    let extensionArgs = map (("-X"++) . C.prettyShow) $ C.defaultExtensions compBI

    -- CPP includes, i.e. include cabal_macros.h
    let cppFlags = map ("-optP"++) $
            [ "-include", compAutogenDir ++ "/cabal_macros.h" ]
            ++ C.cppOptions compBI

    -- Unlike other modules, the main-is module of an executable is not
    -- guaranteed to share a module name with its filepath name. That is,
    -- even though the main-is module is named Main, its filepath might
    -- actually be Something.hs. To account for this possibility, we simply
    -- pass the full path to the main-is module instead.
    -- mainIsPath <- T.traverse (findFile iArgsNoPrefix) (compMainIs comp)

    let deps = map ("-package-id=" ++) unitIds

    let all_sources = map C.prettyShow module_sources
                      ++ additionalModules
    --                  ++ maybeToList mainIsPath

    let flags = concat
            [ iArgs
            , includeArgs
            , dbFlags
            , cppFlags
            , extensionArgs
            , additionalFlags
            ]

    let args = flags ++ deps ++ all_sources
    traverse_ putStrLn args

    Doctest.doctest args
  where
    libBI = C.libBuildInfo lib
    docBI = C.testBuildInfo doc

    compBI = libBI

    unitIds :: [String]
    unitIds =
        [ T.unpack uid
        | ci <- Map.elems (P.uComps libUnit) ++ Map.elems (P.uComps docUnit)
        , P.UnitId uid <- Set.toList (P.ciLibDeps ci)
        ]

    -- TODO
    -- distPref = fromFlag (buildDistPref flags)

    -- TODO: `words` is not proper parser (no support for quotes)
    additionalModules = maybe [] words
        $ lookup "x-doctest-modules"
        $ C.customFieldsBI docBI

    additionalFlags = maybe [] words
        $ lookup "x-doctest-options"
        $ C.customFieldsBI docBI

    additionalDirs = maybe [] words
        $ lookup "x-doctest-source-dirs"
        $ C.customFieldsBI docBI

    compDistDir    = maybe "." id (P.uDistDir libUnit)
    testDistDir    = maybe "." id (P.uDistDir docUnit)
    distPref       = compDistDir </> "build"
    compAutogenDir = distPref </> "autogen"


cabal
    :: C.PackageDescription
    -> C.CondTree C.ConfVar [C.Dependency] C.Library
    -> C.CondTree C.ConfVar [C.Dependency] C.TestSuite
    -> P.PlanJson
    -> FilePath
    -> IO ()
cabal pd glib gdoc plan rootDir = do
    print pkgName
    print rootDir
    libUnit <- singleUnit libUnits
    docUnit <- singleUnit docUnits
    cabal' libUnit docUnit lib doc
  where
    pkgName :: String
    pkgName = C.unPackageName $ C.pkgName $ C.package pd


    -- write enabled components, i.e. x-doctest-components
    -- if none enabled, pick library
    -- TODO

    libUnits :: [P.Unit]
    libUnits =
        [ u
        | (_unitId, u) <- Map.toList (P.pjUnits plan)
        , P.UnitTypeLocal == P.uType u
        , let P.PkgId (P.PkgName name) _ = P.uPId u
        , name == T.pack pkgName
        , (compName, _ci) <- Map.toList (P.uComps u)
        , compName == P.CompNameLib
        ]

    docUnits :: [P.Unit]
    docUnits =
        [ u
        | (_unitId, u) <- Map.toList (P.pjUnits plan)
        , P.UnitTypeLocal == P.uType u
        , let P.PkgId (P.PkgName name) _ = P.uPId u
        , name == T.pack pkgName
        , (compName, _ci) <- Map.toList (P.uComps u)
        , compName == P.CompNameTest "doctests"
        ]

    (_libDeps, lib) = C.simplifyCondTree evalCond glib
    (_docDeps, doc) = C.simplifyCondTree evalCond gdoc

    singleUnit :: [P.Unit] -> IO P.Unit
    singleUnit [x] = return x
    singleUnit []  = die "No units found in install plan"
    singleUnit _   = die "Multiple units found"

    -- destruct plan
    P.PkgId (P.PkgName compilerName) compilerVersion = P.pjCompilerId plan

    -- TODO: we should know this from compiling ourselves
    evalCond :: C.ConfVar -> Either C.ConfVar Bool
    evalCond (C.Impl c vr) = Right $
        T.toLower (T.pack (C.prettyShow c)) == T.toLower compilerName
        && C.withinRange (pVerToVersion compilerVersion) vr

    -- TODO:
    evalCond c = error (show c)

pVerToVersion :: P.Ver -> C.Version
pVerToVersion (P.Ver vs) = C.mkVersion vs

-------------------------------------------------------------------------------
-- Utilities
-------------------------------------------------------------------------------

die :: String -> IO a
die err = do
    hPutStrLn stderr err
    exitFailure

{-

-- | Like Cabal's 'C.simplifyCondTree', but for unclear cases use both branches
simplifyCondTree
    :: (Monoid a, Monoid d)
    => (v -> Maybe Bool)
    -> C.CondTree v d a
    -> (d, a)
simplifyCondTree env (CondNode a d ifs) =
    mconcat $ (d, a) : concatMap simplifyIf ifs
  where
    simplifyIf (C.CondBranch cnd t me) =
        case simplifyCondition cnd env of
          (Lit True, _) -> Just $ simplifyCondTree env t
          (Lit False, _) -> fmap (simplifyCondTree env) me
          _ -> Nothing
-}
